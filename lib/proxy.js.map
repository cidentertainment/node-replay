{"version":3,"sources":["proxy.js"],"names":["assert","require","EventEmitter","HTTP","HTTPS","Stream","URL","createGzip","istextorbinary","debug","module","exports","ProxyRequest","IncomingMessage","constructor","options","proxy","method","toUpperCase","protocol","_defaultAgent","host","hostname","split","port","realPort","url","parse","path","auth","agent","globalAgent","headers","name","value","toLowerCase","toString","flushHeaders","setHeader","ended","body","getHeader","removeHeader","addTrailers","trailers","setTimeout","timeout","callback","setImmediate","setNoDelay","setSocketKeepAlive","write","chunk","encoding","push","end","data","error","captured","emit","response","ProxyResponse","needsGzip","gzip","origResponse","connection","httpVersion","httpVersionMajor","httpVersionMinor","statusCode","statusMessage","rawHeaders","rawTrailers","removeAllListeners","pipe","once","length","JSON","stringify","resume","Error","format","code","errno","flush","abort","isTextSync","Readable","version","parseInt","STATUS_CODES","Object","assign","slice","_body","_read","part","shift","msec","notFound","status"],"mappings":"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","file":"proxy.js","sourcesContent":["// A proxy is a function that receives two arguments, a request object and a callback.\n//\n// If it can generate a respone, it calls callback with null and the response object.  Otherwise, either calls callback\n// with no arguments, or with an error to stop the processing chain.\n//\n// The request consists of:\n// url     - URL object\n// method  - Request method (lower case)\n// headers - Headers object (names are lower case)\n// body    - Request body, an array of body part/encoding pairs\n//\n// The response consists of:\n// version   - HTTP version\n// status    - Status code\n// headers   - Headers object (names are lower case)\n// body      - Array of body parts\n// trailers  - Trailers object (names are lower case)\n//\n// This file defines ProxyRequest, which acts as an HTTP ClientRequest that captures the request and passes it to the\n// proxy chain, and ProxyResponse, which acts as an HTTP ClientResponse, playing back a response it received from the\n// proxy.\n//\n// No actual proxies defined here.\n\n\nconst assert            = require('assert');\nconst { EventEmitter }  = require('events');\nconst HTTP              = require('http');\nconst HTTPS             = require('https');\nconst Stream            = require('stream');\nconst URL               = require('url');\nconst createGzip        = require('zlib').createGzip;\nconst istextorbinary    = require('istextorbinary');\nconst debug             = require('./debug');\n\n\n// HTTP client request that captures the request and sends it down the processing chain.\nmodule.exports = class ProxyRequest extends HTTP.IncomingMessage {\n\n  constructor(options = {}, proxy) {\n    super();\n    this.proxy          = proxy;\n    this.method         = (options.method || 'GET').toUpperCase();\n    const protocol      = options.protocol || (options._defaultAgent && options._defaultAgent.protocol) || 'http:';\n    const [host, port]  = (options.host || options.hostname).split(':');\n    const realPort      = options.port || port || (protocol === 'https:' ? 443 : 80);\n    this.url            = URL.parse(`${protocol}//${host || 'localhost'}:${realPort}${options.path || '/'}`, true);\n    this.auth           = options.auth;\n    this.agent          = options.agent || (protocol === 'https:' ? HTTPS.globalAgent : HTTP.globalAgent);\n    this.headers        = {};\n    if (options.headers)\n      for (let name in options.headers) {\n        let value = options.headers[name];\n        if (value != null)\n          this.headers[name.toLowerCase()] = value.toString();\n      }\n  }\n\n  flushHeaders() {\n  }\n\n  setHeader(name, value) {\n    assert(!this.ended, 'Already called end');\n    assert(!this.body, 'Already wrote body parts');\n    this.headers[name.toLowerCase()] = value;\n  }\n\n  getHeader(name) {\n    return this.headers[name.toLowerCase()];\n  }\n\n  removeHeader(name) {\n    assert(!this.ended, 'Already called end');\n    assert(!this.body, 'Already wrote body parts');\n    delete this.headers[name.toLowerCase()];\n  }\n\n  addTrailers(trailers) {\n    this.trailers = trailers;\n  }\n\n  setTimeout(timeout, callback) {\n    if (callback)\n      setImmediate(callback);\n  }\n\n  setNoDelay(/*nodelay = true*/) {\n  }\n\n  setSocketKeepAlive(/*enable = false, initial*/) {\n  }\n\n  write(chunk, encoding, callback) {\n    assert(!this.ended, 'Already called end');\n    this.body = this.body || [];\n    this.body.push([chunk, encoding]);\n    if (callback)\n      setImmediate(callback);\n  }\n\n  end(data, encoding, callback) {\n    assert(!this.ended, 'Already called end');\n\n    if (typeof data === 'function')\n      [ callback, data ] = [ data, null ];\n    else if (typeof encoding === 'function')\n      [ callback, encoding ] = [ encoding, null ];\n\n    if (data) {\n      this.body = this.body || [];\n      this.body.push([ data, encoding ]);\n    }\n    this.ended = true;\n\n    if (callback)\n      setImmediate(callback);\n\n    this.proxy(this, (error, captured)=> {\n      // We're not asynchronous, but clients expect us to callback later on\n      setImmediate(()=> {\n        if (error)\n          this.emit('error', error);\n        else if (captured) {\n          let response = new ProxyResponse(captured);\n          if (needsGzip(captured)) {\n            debug('Re-gzipping captured response');\n            // We need to drop the content-length if it exists as it will get\n            // changed by the gzip compression. We don't buffer the gzipped\n            // output to calculate the content-length in case it's large.\n            delete response.headers['content-length'];\n            const gzip            = createGzip();\n            const origResponse    = response;\n            gzip.connection       = response.connection;\n            gzip.httpVersion      = response.httpVersion;\n            gzip.httpVersionMajor = response.httpVersionMajor;\n            gzip.httpVersionMinor = response.httpVersionMinor;\n            gzip.statusCode       = response.statusCode;\n            gzip.statusMessage    = response.statusMessage;\n            gzip.headers          = response.headers;\n            gzip.rawHeaders       = response.rawHeaders;\n            gzip.trailers         = response.trailers;\n            gzip.rawTrailers      = response.rawTrailers;\n            response.removeAllListeners('end');\n            response = response.pipe(gzip);\n            response.once('end', () => {\n              debug('Emitting close');\n              response.emit('close');\n            });\n          } else {\n            debug(\n              'not gzipping',\n              captured.headers['content-encoding'],\n              captured.body.length,\n              typeof captured.body[0],\n              JSON.stringify(captured.body[0], null, '  ')\n            );\n          }\n          this.emit('response', response);\n          response.resume();\n        } else {\n          const error = new Error(`${this.method} ${URL.format(this.url)} refused: not recording and no network access`);\n          error.code  = 'ECONNREFUSED';\n          error.errno = 'ECONNREFUSED';\n          this.emit('error', error);\n        }\n      });\n    });\n  }\n\n  flush() {\n  }\n\n  abort() {\n  }\n\n};\n\nfunction needsGzip(captured) {\n  if (captured.headers['content-encoding'] !== 'gzip') {\n    return false;\n  }\n  if (!captured.body.length) {\n    return false;\n  }\n  const data = captured.body;\n  if (typeof data === 'object' && istextorbinary.isTextSync(null, data)) {\n    return true;\n  }\n  return typeof data === 'string';\n}\n\n\n// HTTP client response that plays back a captured response.\nclass ProxyResponse extends Stream.Readable {\n\n  constructor(captured) {\n    super();\n    this.once('end', () => {\n      this.emit('close');\n    });\n\n    this.httpVersion      = captured.version || '1.1';\n    this.httpVersionMajor = this.httpVersion.split('.')[0];\n    this.httpVersionMinor = this.httpVersion.split('.')[1];\n    this.statusCode       = parseInt(captured.statusCode || 200, 10);\n    this.statusMessage    = captured.statusMessage || HTTP.STATUS_CODES[this.statusCode] || '';\n    this.headers          = Object.assign({ }, captured.headers);\n    this.rawHeaders       = (captured.rawHeaders || [].slice(0));\n    this.trailers         = Object.assign({ }, captured.trailers);\n    this.rawTrailers      = (captured.rawTrailers || []).slice(0);\n    // Not a documented property, but request seems to use this to look for HTTP parsing errors\n    this.connection       = new EventEmitter();\n    this._body            = captured.body.slice(0);\n  }\n\n  _read() {\n    const part = this._body.shift();\n    if (part)\n      this.push(part[0], part[1]);\n    else\n      this.push(null);\n  }\n\n  setTimeout(msec, callback) {\n    if (callback)\n      setImmediate(callback);\n  }\n\n  static notFound(url) {\n    return new ProxyResponse({\n      status: 404,\n      body:   [ `No recorded request/response that matches ${URL.format(url)}` ]\n    });\n  }\n\n}\n\n"]}