{"version":3,"sources":["matcher.js"],"names":["assert","require","URL","jsStringEscape","debug","module","exports","Matcher","constructor","request","response","url","regexp","hostname","parse","port","path","method","toUpperCase","headers","name","value","toLowerCase","body","version","statusCode","parseInt","statusMessage","slice","trailers","match","test","data","chunks","rexexp","fromMapping","host","mapping","matchingRequest","resolve","RegExp","matcher"],"mappings":"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","file":"matcher.js","sourcesContent":["// A matcher is a function that, given a request, returns an appropriate response or nothing.\n//\n// The most common use case is to calling `Matcher.fromMapping(mapping)`.\n//\n// The request consists of:\n// url     - URL object\n// method  - Request method (lower case)\n// headers - Headers object (names are lower case)\n// body    - Request body (for some requests)\n//\n// The response consists of:\n// version   - HTTP version\n// status    - Status code\n// headers   - Headers object (names are lower case)\n// body      - Array of body parts\n// trailers  - Trailers object (names are lower case)\n\n\nconst assert         = require('assert');\nconst URL            = require('url');\nconst jsStringEscape = require('js-string-escape');\nconst debug          = require('./debug');\n\n// Simple implementation of a matcher.\n//\n// To create a matcher from request/response mapping use `fromMapping`.\nmodule.exports = class Matcher {\n\n  constructor(request, response) {\n    // Map requests to object properties.  We do this for quick matching.\n    assert(request.url || request.regexp, 'I need at least a URL to match request to response');\n    if (request.regexp) {\n      this.hostname = request.hostname;\n      this.regexp   = request.regexp;\n    } else {\n      const url = URL.parse(request.url);\n      this.hostname = url.hostname;\n      this.port     = url.port;\n      this.path     = url.path;\n    }\n\n    this.method   = (request.method && request.method.toUpperCase()) || 'GET';\n    this.headers  = {};\n    if (request.headers)\n      for (let name in request.headers) {\n        let value = request.headers[name];\n        this.headers[name.toLowerCase()] = value;\n      }\n    this.body = request.body;\n\n    // Create a normalized response object that we return.\n    this.response = {\n      version:        response.version || '1.1',\n      statusCode:     response.statusCode && parseInt(response.statusCode, 10) || 200,\n      statusMessage:  response.statusMessage || '',\n      headers:        {},\n      body:           response.body ? response.body.slice(0) : [],\n      trailers:       {}\n    };\n\n    // Copy over header to response, downcase header names.\n    if (response.headers) {\n      const headers = this.response.headers;\n      for (let name in response.headers) {\n        let value = response.headers[name];\n        headers[name.toLowerCase()] = value;\n      }\n    }\n\n    // Copy over trailers to response, downcase trailers names.\n    if (response.trailers) {\n      const trailers = this.response.trailers;\n      for (let name in response.trailers) {\n        let value = response.trailers[name];\n        trailers[name.toLowerCase()] = value;\n      }\n    }\n  }\n\n\n  // Quick and effective matching.\n  match(request) {\n    const { url, method, headers, body } = request;\n    if (this.hostname && this.hostname !== url.hostname) {\n      debug('hostname does not match', this.hostname, url.hostname);\n      return false;\n    }\n    if (this.regexp) {\n      if (!this.regexp.test(url.path)) {\n        debug('path does not match', this.regexp, url.path);\n        return false;\n      }\n    } else {\n      if (this.port && this.port !== url.port) {\n        debug('port does not match', this.port, url.port);\n        return false;\n      }\n      if (this.path && this.path !== url.path) {\n        debug('path does not match', this.path, url.path);\n        return false;\n      }\n    }\n    if (this.method !== method) {\n      debug('method does not match', this.method, method);\n      return false;\n    }\n\n    for (let name in this.headers)\n      if (this.headers[name] !== headers[name]) {\n        debug('header does not match', name, this.headers[name], headers[name]);\n        return false;\n      }\n\n    if (body) {\n      let data = '';\n      for (let chunks of body)\n        data += chunks[0];\n      data = jsStringEscape(data);\n      if (this.body && this.body !== data) {\n        debug('body does not match', this.body, data);\n        return false;\n      }\n    }\n    debug('matched!', request.url, this.hostname, this.rexexp ? this.rexexp : this.path);\n    return true;\n  }\n\n\n  // Returns new matcher function based on the supplied mapping.\n  //\n  // Mapping can contain `request` and `response` object.  As shortcut, mapping can specify `path` and `method` (optional)\n  // directly, and also any of the response properties.\n  static fromMapping(host, mapping) {\n    assert(!!mapping.path ^ !!mapping.request, 'Mapping must specify path or request object');\n\n    let matchingRequest;\n    if (mapping.path)\n      matchingRequest = {\n        url:    URL.resolve(`http://${host}/`, mapping.path),\n        method: mapping.method\n      };\n    else if (mapping.request.url instanceof RegExp)\n      matchingRequest = {\n        host:     host,\n        regexp:   mapping.request.url,\n        method:   mapping.request.method,\n        headers:  mapping.request.headers,\n        body:     mapping.request.body\n      };\n    else\n      matchingRequest = {\n        url:      URL.resolve(`http://${host}`, mapping.request.url),\n        method:   mapping.request.method,\n        headers:  mapping.request.headers,\n        body:     mapping.request.body\n      };\n\n    const matcher = new Matcher(matchingRequest, mapping.response || {});\n    return function(request) {\n      if (matcher.match(request))\n        return matcher.response;\n    };\n  }\n\n};\n\n"]}